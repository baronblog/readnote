### Python刷题

<br/>

#### 为什么要经常刷题
* 我觉得这相当于就是一次次的考试，只有考试才能知道自己掌握的怎么样，才能查漏补缺，才能日益精进
* 我目前觉得写Python能进深信服就代表Python学到了一定程度，所以以深信服为目标，日常刷题

<br/>

#### Python基础题
* Python的数据结构有哪些？哪些可以改变，哪些不能改变？
    * 区别：对该数据结构进行操作会不会导致该对象的地址发生变化
    * 可变数据结构：list，set， dict
    * 不可变数据结构：str，tuple，int
    * 如何保证不可变对象永远不可变呢？比如a.replace('1','2')，a的值是不会变得，如果想要获取修改后的值，必须自己用另外的变量名指向修改后的变量名
    * 为什么元组可以添加列表或者字典等可变数据类型？从内存的角度来分析，元组里面存的只是该可变数据类型的地址，通过该地址可以访问该可变类型，因为Python的可变数据类型运用的是分离式存储数据，表头和数据分开，表头存储很小，数据区更换不影响表头的地址
<br/>

* Python中进程、线程和协程的用法

<br/>

* Python 中深拷贝和浅拷贝的区别
    * 用途：减少内存的使用；做数据清洗，操作时先备份一份，以防找不到原来的数据
    * 区别：
        * 深拷贝是在内存中重新复制一份另外修改，对复制后的进行修改不影响之前的值，浅复制其实就是加了一个变量指向原来的内存，复制前和复制后的变量修改都会影响内存中的数据
        * 针对不可变类型：不管是深拷贝还是浅拷贝，内存地址都是不变的，所以不可变类型没有深复制浅复制这一说法
        * 针对可变类型：深拷贝出来的对象和原来的对象没有半点关系，更改其中的一个不会影响另外一个；浅拷贝
            * 如果可变类型中无嵌套其他复杂子对象(例如列表里面嵌套列表)，浅复制出来的值和复制之前的值id不一样，并且更改其中一个不会影响另外一个
            * 如果可变类型中嵌套其他复杂子对象，如果改变其中复杂子对象的值，浅复制前后的值都会受到影响
    * 深复制：copy.deepcopy,
    * 浅复制：copy.copy, 切片操作，工厂函数
<br/>

* 计算函数的具体执行时间，怎么做？
    * 使用装饰器来对函数进行计时，本质上就是把函数作为参数传递进去，返回函数内部的函数并调用，达到在不改变原有逻辑的基础上，增加业务逻辑

<br/>

* Python的优势和劣势？ 与PHP相比怎么样？
    * 优势：
        * 第三方库非常多，而且非常方便使用，比如说请求url有requests，web开发有django，flask，科学计算有numpy，pandas，访问数据库有pymysql，MysqlDB等
        * 能很轻松的集成C相关的代码，影响速度的相关处理可以交给C来做，Python专注于自己的事务处理
        * 学习成本相对于C，Java来说，比较低，且Python社区比较活跃，有很多优秀的人来帮助Python成长
    * 劣势：
        * 脚本语言的通病，都是边编译边执行，速度比较慢
        * 有GIL大锁，不能真正的实现多线程，在同一个时间节点，同一进程下面的多线程只能有一个线程在获取GIL锁之后才能运行，其余线程皆处于等待状态
        * 强制缩进
    * 对比PHP：
        * PHP专注于Web开发，专业干好一件事我觉得这就是优势，而且在Web方面支持更多的数据库，有更多的Web框架；Python好像什么都能干，但是这样的我就觉得没啥优势，因为要兼容各个方面(我的理解)
        * PHP 学习成本更低，为什么被称为世界上最好的语言，我的理解有一部分就是入门门槛低，我有脚本经验学习了几天PHP便可以动手二次开发相关的PHP项目
        * PHP 本身就拥有处理文本相关的能力，可以直接混写在html中，但是Python不行，必须借助第三方库来渲染才行

<br/>

<br/>

#### Python数据结构
* 字符串匹配：计算字串第一次出现在主串的位置(KMP算法)
<br/>


* 给定一个数，从最小堆里面找到的这个数的过程是什么？
<br/>

* 100万个域名，快速找出是否包含某个域名
    * 使用字典结构，也就是哈希表，使用关键码(key)通过散列函数映射到某一位置，达到加速查找key/value的速度
<br/>

* 快速排序原理

<br/>

* 冒泡排序原理
    * 冒泡排序思想： 通过一遍遍的遍历，每一次遍历都把相邻两个位置的数据进行比较大小，然后交换位置即可
    * 空间复杂度：因为是在遍历过程中，对列表中的两个值进行两两交换，所以空间复杂度为O(1)
    * 时间复杂度：最好的情况O(k)(如下代码),最差的情况是O(n*n)
    * 优化：
        * 记录每一次遍历是否有顺序的改变，如果没有，则说明排序已经完成，然后直接输出即可，如下代码只遍历了2次即可，可以省下不少时间
        * 遍历的次数，也就是嵌套的第二层，只需要遍历列表的长度-1-第一层已经遍历的次数，因为第一层遍历完一次，代表已经把最大值放入到了倒数第一位，第二次会把倒数第二大的值放入倒数第二位，以此类推
    * 代码如下：
        ```
        def bubble_sort(alist):

            for r in range(len(alist)-1):           #第一层遍历次数应该是列表数值的个数减掉1，例如9个值，只需要比较8次即可
                hasChange = False
                print '遍历第%s次'% str(r)
                for i in range(len(alist)-1-r):     #第二次遍历的次数只需要遍历列表长度-已遍历的次数再减1，因为第一次遍历后，会把最大值放入最后一个，第二次会把倒数第二大的值放入倒数第二，以此类推
                    if alist[i] > alist[i+1]:
                        alist[i], alist[i+1] = alist[i+1], alist[i]
                        hasChange=True
                if not hasChange:
                    return alist

if __name__ == '__main__':
    print bubble_sort([2,1,4,2,5,7,232,222,343,999,34234])
        ```
<br>



#### HTTP协议
* GET和POST的区别？POST和PUT的区别
    * GTE是向后端发起请求，是获取数据，类似于数据库里面的select
    * POST是向后端发起请求，是创建数据，类似于数据库里面的insert
    * PUT是向后端发起请求，是更新数据数据，类似于数据库里面update
