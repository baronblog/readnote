### 记录关于对Python数据结构常见的考点

<br/>

#### Python常见的数据结构取数据复杂度如何
* 列表：知道了索引取数据为O(1)，不知道索引或者直接使用in来判断是否存在，最多可能为O(n)
* 字典：在没有遇到哈希碰撞的情况下，取数据一般为O(1)；如果遇到了碰撞，如果挂的是链表，最多为链表的长度
* 字符串：知道了索引取数据为O(m-n)(m,n之差为索引数之差)，如果使用正则匹配的话，最优解也只能达到nlogN的复杂度
* 哈希冲突如何避免？使用什么方法
    ```
    链地址法
    1. 如果遇到哈希碰撞的情况，可以在该存储区域内挂一个链表，链表节点存入数据和哈希后的值
    2. 取的时候，首先会对输入的值进行哈希，如果遇到了碰撞，再去查链表，分别对比原来的key即可找到
    ```

<br/>
#### 关于对连接池的理解
* 针对Apache的prework模式，使用连接池的效果基本等同于不使用连接池
* 因为Apache的prework模式，是每来一次请求使用一个进程来接待，保持登录状态使用会话信息，每个进度间信息都是单独存在的，所以回到每一个进程，按照同步编程模型编写的代码，每次只能使用连接池里面的一个连接，所以说在这样的情况下多开几个连接，基本属于浪费
* 连接池最好使用的情况应该为多线程，在同一个进程下，多个线程即使有GIL大锁，每个线程都可以获得自己的连接，而不是每次都需要创建一次连接
<br/>

#### Linux下找出文本文件中某一关键词出现的次数
* grep -o 'hello' a.txt | wc -l
* grep是一个Linux常用的命令，值得学习一下:[资料来源](https://www.cnblogs.com/flyor/p/6411140.html)
* **grep 匹配格式：grep  [选项]  ”模式“  [文件]**
    ```
        常用选项：
    　　-E ：开启扩展（Extend）的正则表达式。

    　　-i ：忽略大小写（ignore case）。

    　　-v ：反过来（invert），只打印没有匹配的，而匹配的反而不打印。

    　　-n ：显示行号

    　　-w ：被匹配的文本只能是单词，而不能是单词中的某一部分，如文本中有liker，而我搜寻的只是like，就可以使用-w选项来避免匹配liker

    　　-c ：显示总共有多少行被匹配到了，而不是显示被匹配到的内容，注意如果同时使用-cv选项是显示有多少行没有被匹配到。

    　　-o ：只显示被模式匹配到的字符串。

    　　--color :将匹配到的内容以颜色高亮显示。

    　　-A  n：显示匹配到的字符串所在的行及其后n行，after

    　　-B  n：显示匹配到的字符串所在的行及其前n行，before

    　　-C  n：显示匹配到的字符串所在的行及其前后各n行，context
    ```

<br/>

#### Linux常用的命令(只记录工作相关，不记录很常用的命令)
    * ps aux | grep httpd: 查看httpd的进程
    * killall|kill -9 PID: 杀死相关进程
    * tailf debug: 动态查看相关日志
    * lsof -i:8080:查看8080端口是否被占用
    * cat /proc/pid: 查看pid进程的相关信息
    * find / -name a.txt：查找文件名为a.txt的文件
    * rm -rf a.txt：删除文件且不确认
    * mv/cp：复制或者移动文件
    * scp -P 1234 root@xx：/dev/a.txt /: 不同机器复制文件
    * mkdir -p  /var/www：创建文件，如果父目录没有，也一起创建
    * ifconfig eth 10.10.10.161/24:配置IP
    * clear：清屏
