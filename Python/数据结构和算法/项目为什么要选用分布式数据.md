### 项目为什么要选用分布式数据

<br/>

#### 简介
* 一直以来，我们都习惯于用传统的关系型数据库，稳定，解决方案多，数据量大了可以使用分库分表，主从等方式减小压力，一直是中小型企业的不二之选
* 第一步有压力后，还可以用提升数据库机器等参数来提升性能，但是并发再多呢？
* 在一定的数据量范围内，关系型数据库是可以满足要求的，但是如果数据大于1000万呢？大约1亿呢？单张表或者分库分表就承受不了这样的压力，所以分布式数据库的优点就体现出来了

<br/>

#### 分布式数据库ETCD
* 闲谈
    ```
    * 曾经有两位功力比我厉害的大牛问过我分布式数据库相关底层原理，我都没回答上来，事不过三，特意写下此文
    * 能被人看的github，并且就自己写的内容和自己讨论，这是一件非常高兴的事情，我觉得很有写下去的必要，这也是我的动力之一！！！！！！！！
    ```
* 简介
    ```
    * etcd是一个高可用的分布式key-value数据库，基于GO语言实现，内部采用raft算法保持各个节点数据的一致性
    * 安装简单，提供HTTP API接口供调用，且支持服务发现
    ```
* ETCD 中使用了raft算法，那raft算法是如何保持一致性的呢？
    ```

    * 集群中分为3中角色：候选者，跟随者，领导者
        * 领导者：负责处理来自客户端的请求信息，并把数据包含在心跳包里面，发送给各个跟随者，保证节点数据一致
        * 跟随者：当集群启动的时候，所有节点均为跟随者状态。作用为转发客户端请求给领导者以及响应领导者的同步数据请求，以及响应投票请求
        * 候选者：当集群中无领导者的时候，根据一定要求，谁先反应过来谁就是候选者，给自己投一票，投票选举完成之后，成为领导者状态

    * 是如何进行选举成为领导者的呢？(注意：投票中的服务是无法对外提供服务的)
        * 在服务启动时，所有的节点都是跟随者的状态
        * 每个节点都有一个定时器，触发投票机制，节点状态由跟随者转为候选者，然后向其他节点发起投票请求，会有以下三种状态：
            * 候选者发起的投票机制大于1/2的节点数，便该节点成功领导者状态，开始履行领导者的职责
            * 收到投票信息后，发现有其他节点的票数大于本节点投票，该节点立即由候选者状态改为追随者状态，反之保留候选者状态，且拒绝投票，因为他的这一票已经投给自己了
            * 选举期间如果发生了超时，重新进行新一届的选择，也就是Term会增加
    
    * 日志复制：保证各个节点的数据一致性和高可用
        * 领导者被选举出来之后，所有的请求数据都要被领导者处理
        * 当客户端发起请求后，需要转给领导者处理；领导者处理后，会增加一条对应的日志记录。
        * 领导者处理成功后，通过发送心跳信息的时候把这条信息发给追随者，追随者在接到信息后，发送ack信息给领导者，领导者接到1/2以上节点的ack信息后，将此日志信息设置为已提交，写入本地磁盘
        * 在下一次发送心跳信息的时候，通知追随者把日志信息写入磁盘

    ```
