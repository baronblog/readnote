# Threading模块

## 问题备注
* 在学习使用Threading模块之前，导入的时候曾经看到过Thread模块，虽然都可以创建线程进行使用，但一般建议使用Threading模块，因为该模块比Thread模块好，
比如说Thread模块在主线程退出后，其他线程都会无警告的直接挂掉，Threading会默认主线程退出后，重要的子线程完成后再退出
* 使用Threading模块中有start和run方法来启动线程，但区别不同的是start是在主线程中再次开辟一个子线程，如果有多个，就在主线程中开辟多个子线程，run方法
就是在主线程中调用函数，并不开辟子线程，这个可以打印线程的名字来区分，使用threading.current_thread().getName()来获取线程名字，如果是主线程就是
MainThread，子线程就是Thread-N，N代表线程的编号
* 多线程的时候，遇到IO操作会进行切换，或者遇到释放GIL锁的时候也会切换，会笔记省时间，所以遇到IO操作的最好用多线程，计算密集型最好用多进程
* Python 有全局GIL锁，每次只能运行一个线程，所以这样发挥不了多核的优势


## 经典的线程加减法
* 原理：多个线程操作同一对象，会出现线程不同步的问题，在类中，类变量所有实例共享
* 案例讲解：
```
需求：num=0，现在要对这个值加5次，每次加1，之后再减5次，每次减1，开启两个线程，一个线程加，一个线程减
结果：每次结果都不固定，有的时候为正，有时候为负数，没有一次为0的

每次结果不为0，是因为：
1.python多线程中有GIL锁的存在，每次只能运行一个线程，如果有多线程，便会交替执行
2.在交替执行的时候，多线程分条执行计算机的语句会出问题

高级语言(Python)中是这样写的：
num=0 
num=num+1

计算机中是这样执行的：
num=0
x=num+1
num=x

第一次:
x=0+1
num=1

第二次：
x=1+1
num=2

第三次
x=2+1

在这里，释放了GIL锁，切换到另外的一个线程去做
第四次
num=2
x=num-1
num=x

x=2-1
num=1

之后就切换回去第一个线程
x=3
n=3

在这里就有问题了，第一个线程用2进行了加1，第二个线程又在使用2进行运算，其实第二个线程应该拿着3进行运算，否则会有问题
```


